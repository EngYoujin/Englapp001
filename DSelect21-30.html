<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>単語帳学習アプリ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans JP', 'Inter', sans-serif; }
        .quiz-container { max-width: 800px; width: 95%; }
        .step-indicator.active { background-color: #3b82f6; color: white; font-weight: bold; }
        .btn-option:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .flashcard { perspective: 1000px; cursor: pointer; }
        .flashcard-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; }
        .flashcard.flipped .flashcard-inner { transform: rotateY(180deg); }
        .flashcard-front, .flashcard-back { position: absolute; width: 100%; height: 100%; -webkit-backface-visibility: hidden; backface-visibility: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 1rem; border-radius: 0.75rem; border: 1px solid #d1d5db; }
        .flashcard-front { background-color: white; }
        .flashcard-back { background-color: #f0f9ff; transform: rotateY(180deg); }
        .speaker-btn { position: absolute; top: 10px; right: 10px; color: #6b7280; }
        .speaker-btn:hover { color: #3b82f6; }
        .tooltip-trigger { border-bottom: 2px dotted #3b82f6; cursor: pointer; position: relative; }
        .tooltip-content { visibility: hidden; width: max-content; max-width: 250px; background-color: #1f2937; color: #fff; text-align: center; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .tooltip-trigger:hover .tooltip-content { visibility: visible; opacity: 1; }
        .review-mark {
            display: inline-block;
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
            background-color: #ef4444;
            border-radius: 9999px;
            width: 1.1rem;
            height: 1.1rem;
            line-height: 1.1rem;
            text-align: center;
            margin-left: 0.25rem;
        }
        .toc-item-content {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .segment { display: inline-flex; border: 1px solid #d1d5db; border-radius: 9999px; overflow: hidden; }
        .segment button { border: 0; background-color: white; padding: 0.5rem 0.75rem; font-size: 0.875rem; cursor: pointer; min-height: 36px; transition: background-color 0.2s, color 0.2s; }
        .segment button.on { background-color: #1f2937; color: white; }
    </style>
</head>
<body class="bg-gray-100 pt-20 pb-8 min-h-screen">

    <header class="bg-white border-b fixed top-0 left-0 right-0 z-50 shadow-sm">
        <div class="quiz-container mx-auto p-3 flex justify-between items-center">
            <h1 class="text-lg font-bold text-gray-800">Deselect 高機能版</h1>
            <div class="flex items-center gap-4 text-sm">
                <a href="#" id="header-toc-link" class="text-gray-600 hover:text-blue-500">目次</a>
                <a href="#" id="header-review-link" class="text-gray-600 hover:text-blue-500 relative">
                    今日の復習
                    <span id="header-review-badge" class="absolute -top-2 -right-3 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center hidden"></span>
                </a>
                <button id="reset-data-btn" class="bg-gray-100 hover:bg-gray-200 text-gray-700 font-semibold py-1 px-3 border border-gray-300 rounded-full">
                    リセット
                </button>
            </div>
        </div>
    </header>

    <div id="app-container" class="quiz-container mx-auto bg-white rounded-2xl shadow-lg p-6 md:p-8">
        
        <!-- Table of Contents Screen (Main Menu) -->
        <div id="toc-screen">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800 text-center mb-4">DUOセレクト学習</h1>
            <p class="text-gray-600 text-center mb-8">学習したい例文を選ぶか、最初から全ての問題に挑戦しましょう。</p>
            
            <div id="review-banner-container" class="mb-8"></div>

            <div class="flex justify-center items-center gap-x-6 gap-y-4 flex-wrap mb-8 text-sm text-gray-600 border bg-gray-50 p-4 rounded-lg">
                <span class="flex items-center">
                    <i class="fas fa-sliders-h mr-2 text-gray-500"></i><strong>音声・表示設定</strong>
                </span>
                <span>速度: <input id="rate" type="range" min="0.6" max="1.4" step="0.1" value="1" class="align-middle w-24"></span>
                <span class="flex items-center">声:
                    <span class="segment ml-2" id="voiceSeg">
                        <button data-v="auto" class="on">自動</button>
                        <button data-v="male">男</button>
                        <button data-v="female">女</button>
                    </span>
                </span>
                <span class="flex items-center">単語カード:
                    <span class="segment ml-2" id="cardModeSeg">
                        <button data-v="en-ja" class="on">認識 (英→日)</button>
                        <button data-v="ja-en">想起 (日→英)</button>
                    </span>
                </span>
                <span class="flex items-center">想起ヒント:
                    <span class="segment ml-2" id="hintModeSeg">
                        <button data-v="on" class="on">ON</button>
                        <button data-v="off">OFF</button>
                    </span>
                </span>
            </div>

            <div class="border-b pb-8 mb-8">
                <h2 class="text-lg font-bold text-gray-700 text-center mb-4">メイン学習</h2>
                <button id="start-sequential-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full text-lg transition-transform transform hover:scale-105">
                    最初から順番に全ての問題をやる
                </button>
            </div>

            <div>
                <h2 class="text-lg font-bold text-gray-700 text-center mb-4">個別学習・復習</h2>
                <div id="toc-list" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div>
            </div>
            
            <div class="border-t pt-8 mt-8">
                 <h2 class="text-lg font-bold text-gray-700 text-center mb-4">腕試し</h2>
                 <button id="final-check-btn" class="w-full bg-white hover:bg-gray-100 text-gray-700 font-semibold py-2 px-6 border border-gray-300 rounded-full">
                    まとめて最終チェック
                </button>
            </div>
        </div>

        <!-- Review Area -->
        <div id="review-area" class="hidden">
             <!-- This will be populated by renderReview() -->
        </div>

        <!-- Main Quiz Area -->
        <div id="main-quiz-area" class="hidden">
            <!-- Progress and Title -->
            <div class="flex justify-between items-center mb-2">
                 <button id="back-to-toc-btn" class="text-blue-500 hover:text-blue-700 font-semibold"><i class="fas fa-arrow-left mr-2"></i>目次に戻る</button>
                <p id="question-counter" class="text-gray-500 font-medium"></p>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5 mb-4">
                <div id="progress-bar" class="bg-blue-500 h-2.5 rounded-full" style="width: 0%; transition: width 0.3s ease-in-out;"></div>
            </div>
            <!-- Step Indicators -->
            <div class="flex justify-center space-x-1 md:space-x-2 mb-6 text-xs md:text-sm" id="step-indicators-container">
                <button data-step="1" class="step-indicator border border-gray-300 rounded-full px-3 py-1 text-gray-600 transition-all duration-300">1:クイズ</button>
                <button data-step="2" class="step-indicator border border-gray-300 rounded-full px-3 py-1 text-gray-600 transition-all duration-300">2:応用</button>
                <button data-step="3" class="step-indicator border border-gray-300 rounded-full px-3 py-1 text-gray-600 transition-all duration-300">3:単語カード</button>
            </div>

            <!-- Step Views -->
            <div id="step-views">
                <div id="step1-quiz" class="step-view"></div>
                <div id="step2-application" class="step-view hidden"></div>
                <div id="step3-flashcards" class="step-view hidden"></div>
            </div>
            
            <!-- Navigation -->
            <div class="text-center mt-6">
                <button id="next-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-8 rounded-full transition-colors hidden">次へ</button>
            </div>

            <!-- Sentence Navigation -->
            <div id="sentence-nav" class="flex justify-between mt-4 pt-4 border-t">
                <button id="prev-sentence-btn" class="text-blue-500 hover:text-blue-700 font-semibold disabled:opacity-50 disabled:cursor-not-allowed"><i class="fas fa-chevron-left mr-2"></i>前の例文</button>
                <button id="next-sentence-btn" class="text-blue-500 hover:text-blue-700 font-semibold disabled:opacity-50 disabled:cursor-not-allowed">次の例文<i class="fas fa-chevron-right ml-2"></i></button>
            </div>
        </div>
        
        <!-- Final Check Area -->
        <div id="final-check-area" class="hidden">
            <div class="flex justify-between items-center mb-4">
                 <button id="back-to-toc-from-final-btn" class="text-blue-500 hover:text-blue-700 font-semibold"><i class="fas fa-arrow-left mr-2"></i>目次に戻る</button>
                 <button id="shuffle-final-check-btn" class="text-blue-500 hover:text-blue-700 font-semibold"><i class="fas fa-random mr-2"></i>順番をシャッフル</button>
            </div>
            <h2 class="text-2xl font-bold text-gray-800 text-center mb-4">まとめて最終チェック</h2>
            <p id="final-check-description" class="text-sm text-gray-500 text-center mb-6">日本語を見て、対応する英単語を思い出してみましょう。カードをタップすると答えが表示されます。</p>
            <div id="final-check-flashcards" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
        </div>

        <!-- Result Screen -->
        <div id="result-screen" class="hidden text-center">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">全問終了！お疲れ様でした！</h2>
            <p class="text-lg text-gray-700 mb-6">学習結果を確認しましょう。</p>
            <div id="self-assessment-summary"></div>
            <div class="mt-8">
                <button id="review-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-full text-lg transition-transform transform hover:scale-105 mr-4">目次で復習する</button>
            </div>
        </div>
    </div>

<script>
// --- LEARNING APP LOGIC ---
/*
================================================================================
TEMPLATE INSTRUCTION / テンプレート利用方法
================================================================================
以下の `const quizData = [ ... ];` の `[` と `]` の間に、
新しい例文データを貼り付けてください。

- 各例文は `{ ... }` の形式で記述します。
- 例文と例文の間は、必ず `,` (カンマ) で区切ってください。
- 最後の例文の後ろには `,` (カンマ) を付けないでください。

貼り付け例：
const quizData = [
    {
        "id": 11,
        "originalSentence": "...",
        // ... (例文11のデータ)
    },
    {
        "id": 12,
        "originalSentence": "...",
        // ... (例文12のデータ)
    }
    // ... 最後の例文まで続く
];
================================================================================
*/
const quizData = [
    {
        id: 21,
        originalSentence: "Take your time and let's deal with the problems one by one.",
        translation: "慌てないで。一つずつ問題に対処しよう。",
        quiz: { target: "deal with", choices: ["deal with", "get over", "look for", "turn down"], meaning: "～に対処する" },
        application: {
            situation: "山積みのタスクリストを見て、どこから手をつけていいか分からずパニックになっている同僚に。",
            sentence: "Don't <span class='tooltip-trigger'>panic<span class='tooltip-content'>panic = パニックになる</span></span>. Let's just <span class='tooltip-trigger'>deal with<span class='tooltip-content'>～に対処する</span></span> these tasks systematically.",
            translation: "パニックにならないで。一つひとつ、体系的にこれらのタスクを片付けていこう。"
        },
        flashcards: [
            { en: "deal with", ja: "～に対処する", kana: "**ディー**ル・ウィズ", phonetic: "/diːl wɪð/", hint: "d" },
            { en: "take one's time", ja: "ゆっくりやる、慌てない", kana: "**テイ**ク・ワンズ・**タ**イム", phonetic: "/teɪk wʌnz taɪm/", hint: "t" },
            { en: "one by one", ja: "一つひとつ", kana: "**ワ**ン・バイ・**ワ**ン", phonetic: "/wʌn baɪ wʌn/", hint: "o" }
        ]
    },
    {
        id: 22,
        originalSentence: "It's no use arguing with him, so take it easy.",
        translation: "彼と口論しても無駄だよ。気楽にいこう。",
        quiz: { target: "It's no use arguing", choices: ["It's no use arguing", "It's worth trying", "It's fun learning", "It's hard saying"], meaning: "口論しても無駄だ" },
        application: {
            situation: "試合の結果に納得できず、ずっと文句を言っている友達に「もう終わったことだよ」と声をかける時。",
            sentence: "The game is over. It's no use arguing about the <span class='tooltip-trigger'>referee's call<span class='tooltip-content'>call = (審判などの)判定</span></span> now.",
            translation: "試合は終わったんだ。今さら審判の判定について口論したって無駄だよ。"
        },
        flashcards: [
            { en: "It's no use -ing", ja: "～しても無駄だ", kana: "イッツ・ノー・ユース", phonetic: "/ɪts noʊ juːs/", hint: "I" },
            { en: "Take it easy.", ja: "気楽にね、落ち着いて", kana: "**テイ**ク・イット・**イー**ジー", phonetic: "/teɪk ɪt ˈiːzi/", hint: "T" },
            { en: "argue", ja: "口論する", kana: "**アー**ギュー", phonetic: "/ˈɑːrɡjuː/", hint: "a" }
        ]
    },
    {
        id: 23,
        originalSentence: "I was truly amazed that this tiny device is so smart.",
        translation: "この小さな装置が賢いことに本当に驚いた。",
        quiz: { target: "amazed", choices: ["amazed", "bored", "frightened", "excited"], meaning: "（とても）驚いて" },
        application: {
            situation: "最新のワイヤレスイヤホンを買ったら、あまりの音質の良さと機能の多さに感動した。",
            sentence: "I was honestly <span class='tooltip-trigger'>amazed<span class='tooltip-content'>(とても)驚いて</span></span> by how good these new <span class='tooltip-trigger'>earbuds<span class='tooltip-content'>earbuds = (耳に入れるタイプの)イヤホン</span></span> sound. The noise-canceling is incredible.",
            translation: "この新しいイヤホンの音の良さには正直、本当に驚いたよ。ノイズキャンセリングが信じられないくらいすごい。"
        },
        flashcards: [
            { en: "be amazed", ja: "とても驚く", kana: "ビー・ア**メ**イズド", phonetic: "/bi əˈmeɪzd/", hint: "b" },
            { en: "device", ja: "装置", kana: "ディ**ヴァ**イス", phonetic: "/dɪˈvaɪs/", hint: "d" },
            { en: "tiny", ja: "とても小さい", kana: "**タ**イニー", phonetic: "/ˈtaɪni/", hint: "t" },
            { en: "smart", ja: "賢い", kana: "ス**マー**ト", phonetic: "/smɑːrt/", hint: "s" }
        ]
    },
    {
        id: 24,
        originalSentence: "Although he's a biologist, he's frightened of insects.",
        translation: "彼は生物学者なのに、虫を怖がるんだ。",
        quiz: { target: "frightened", choices: ["frightened", "amazed", "bored", "ashamed"], meaning: "おびえて、怖がって" },
        application: {
            situation: "ホラー映画は苦手だけど、なぜか見てしまう友達。",
            sentence: "It's funny, she's <span class='tooltip-trigger'>frightened<span class='tooltip-content'>おびえて、怖がって</span></span> of <span class='tooltip-trigger'>ghosts<span class='tooltip-content'>ghost = 幽霊</span></span>, but she loves watching horror movies.",
            translation: "面白いよね、彼女、お化けを怖がるのにホラー映画を見るのは大好きなんだ。"
        },
        flashcards: [
            { en: "be frightened of", ja: "～を怖がる", kana: "ビー・フ**ラ**イトゥンド・オブ", phonetic: "/bi ˈfraɪtnd əv/", hint: "b" },
            { en: "insect", ja: "昆虫", kana: "**イ**ンセクト", phonetic: "/ˈɪnsekt/", hint: "i" },
            { en: "biology", ja: "生物学", kana: "バイ**オ**ロジー", phonetic: "/baɪˈɑːlədʒi/", hint: "b" }
        ]
    },
    {
        id: 25,
        originalSentence: "The topic was so boring, no wonder the audience fell asleep.",
        translation: "話題が退屈だったので、観客が眠ってしまったのも無理はない。",
        quiz: { target: "No wonder", choices: ["No wonder", "No problem", "No way", "No doubt"], meaning: "～なのも当然だ" },
        application: {
            situation: "いつも行列ができているラーメン屋さん。実際に食べてみたら、ものすごく美味しかった。",
            sentence: "<span class='tooltip-trigger'>No wonder<span class='tooltip-content'>～なのも当然だ</span></span> there's always a <span class='tooltip-trigger'>line out the door<span class='tooltip-content'>line out the door = ドアの外まで続く行列</span></span>. This ramen is incredible!",
            translation: "いつも行列ができているのも当然だね。このラーメン、信じられないくらい美味しい！"
        },
        flashcards: [
            { en: "No wonder", ja: "～なのも当然だ", kana: "**ノ**ウ・**ワ**ンダー", phonetic: "/noʊ ˈwʌndər/", hint: "N" },
            { en: "audience", ja: "聴衆", kana: "**オー**ディエンス", phonetic: "/ˈɔːdiəns/", hint: "a" },
            { en: "bored", ja: "（人が）退屈して", kana: "**ボー**ド", phonetic: "/bɔːrd/", hint: "b" },
            { en: "topic", ja: "話題", kana: "**ト**ピック", phonetic: "/ˈtɑːpɪk/", hint: "t" }
        ]
    },
    {
        id: 26,
        originalSentence: "Now that you're an adult, you should respect each other.",
        translation: "君はもう大人なのだから、お互いを尊重すべきだ。",
        quiz: { target: "Now that", choices: ["Now that", "Even if", "As long as", "Just because"], meaning: "今や～なので" },
        application: {
            situation: "運転免許を取ったばかりの友達に、ドライブに連れて行ってもらう約束をする。",
            sentence: "<span class='tooltip-trigger'>Now that<span class='tooltip-content'>今や～なので</span></span> you have your <span class='tooltip-trigger'>driver's license<span class='tooltip-content'>driver's license = 運転免許証</span></span>, you have to take me to the beach!",
            translation: "もう運転免許を取ったんだから、私をビーチに連れて行ってくれなきゃ！"
        },
        flashcards: [
            { en: "Now that", ja: "今や～なので", kana: "**ナ**ウ・ザット", phonetic: "/naʊ ðæt/", hint: "N" },
            { en: "get married", ja: "結婚する", kana: "**ゲ**ット・**マ**リード", phonetic: "/ɡet ˈmærid/", hint: "g" },
            { en: "respect", ja: "～を尊重する", kana: "リ**スペ**クト", phonetic: "/rɪˈspekt/", hint: "r" }
        ]
    },
    {
        id: 27,
        originalSentence: "I got lost, and to make matters worse, my phone broke down.",
        translation: "道に迷い、さらに悪いことに、携帯が壊れた。",
        quiz: { target: "broke down", choices: ["broke down", "gave up", "turned off", "got lost"], meaning: "故障した" },
        application: {
            situation: "大事なプレゼンの日に寝坊。急いで準備をしていたら、さらに悪いことが…。",
            sentence: "I <span class='tooltip-trigger'>overslept<span class='tooltip-content'>oversleep = 寝坊する</span></span> on the day of my big presentation. <span class='tooltip-trigger'>To make matters worse<span class='tooltip-content'>さらに悪いことに</span></span>, my laptop wouldn't turn on.",
            translation: "大事なプレゼンの日に寝坊しちゃったんだ。さらに悪いことに、ノートパソコンが起動しなかったんだ。"
        },
        flashcards: [
            { en: "break down", ja: "故障する", kana: "**ブ**レイク・**ダ**ウン", phonetic: "/breɪk daʊn/", hint: "b" },
            { en: "get lost", ja: "道に迷う", kana: "**ゲ**ット・**ロ**スト", phonetic: "/ɡet lɔːst/", hint: "g" },
            { en: "to make matters worse", ja: "さらに悪いことに", kana: "トゥ・**メイ**ク・**マ**ターズ・**ワー**ス", phonetic: "/tu meɪk ˈmætərz wɜːrs/", hint: "t" }
        ]
    },
    {
        id: 28,
        originalSentence: "I'm so excited about getting together with my old friends.",
        translation: "旧友たちと集まるのがとても楽しみだ。",
        quiz: { target: "excited", choices: ["excited", "amazed", "bored", "frightened"], meaning: "わくわくして" },
        application: {
            situation: "好きなアーティストのライブが来週に迫っている。",
            sentence: "The concert is next week! I'm so <span class='tooltip-trigger'>excited<span class='tooltip-content'>わくわくして</span></span>, I can <span class='tooltip-trigger'>hardly wait<span class='tooltip-content'>hardly wait = 待ちきれない</span></span>.",
            translation: "ライブは来週だ！すっごくわくわくして、待ちきれないよ。"
        },
        flashcards: [
            { en: "be excited about", ja: "～にわくわくしている", kana: "ビー・イグ**ザ**イティド・ア**バ**ウト", phonetic: "/bi ɪkˈsaɪtɪd əˈbaʊt/", hint: "b" },
            { en: "get together", ja: "集まる", kana: "**ゲ**ット・トゥ**ゲ**ザー", phonetic: "/ɡet təˈɡeðər/", hint: "g" },
            { en: "So am I.", ja: "私もです。", kana: "**ソ**ウ・アム・**ア**イ", phonetic: "/soʊ æm aɪ/", hint: "S" }
        ]
    },
    {
        id: 29,
        originalSentence: "If we argue, the tension in our relationship will get worse.",
        translation: "もし私たちが口論すれば、二人の関係の緊張はさらに悪化するだろう。",
        quiz: { target: "tension", choices: ["tension", "attention", "solution", "tradition"], meaning: "緊張（状態）" },
        application: {
            situation: "グループプロジェクトで意見が対立。締め切りが近づくにつれて、メンバー間の雰囲気が悪くなってきた。",
            sentence: "You could feel the <span class='tooltip-trigger'>tension<span class='tooltip-content'>緊張(状態)</span></span> in the room as the project <span class='tooltip-trigger'>deadline<span class='tooltip-content'>deadline = 締め切り</span></span> got closer.",
            translation: "プロジェクトの締め切りが近づくにつれて、部屋の緊張感が感じられたよ。"
        },
        flashcards: [
            { en: "tension", ja: "緊張（状態）", kana: "**テ**ンション", phonetic: "/ˈtenʃn/", hint: "t" },
            { en: "negotiation", ja: "交渉", kana: "ネゴシ**エイ**ション", phonetic: "/nəˌɡoʊʃiˈeɪʃn/", hint: "n" },
            { en: "fail", ja: "失敗する", kana: "**フェ**イル", phonetic: "/feɪl/", hint: "f" },
            { en: "get worse", ja: "悪化する", kana: "**ゲ**ット・**ワー**ス", phonetic: "/ɡet wɜːrs/", hint: "g" }
        ]
    },
    {
        id: 30,
        originalSentence: "The competition between the two rivals grew more and more intense.",
        translation: "その二人のライバル間の競争はますます激しくなった。",
        quiz: { target: "intense", choices: ["intense", "solid", "vague", "rare"], meaning: "激しい" },
        application: {
            situation: "応援しているスポーツチームが、ライバルチームと接戦を繰り広げている。",
            sentence: "The <span class='tooltip-trigger'>rivalry<span class='tooltip-content'>rivalry = ライバル関係</span></span> between the two teams is so <span class='tooltip-trigger'>intense<span class='tooltip-content'>激しい</span></span>. Every match is a <span class='tooltip-trigger'>must-win<span class='tooltip-content'>must-win = 絶対に勝たなければならない試合</span></span>.",
            translation: "あの2チームのライバル関係はすごく激しい。どの試合も絶対に負けられないんだ。"
        },
        flashcards: [
            { en: "intense", ja: "激しい", kana: "イン**テ**ンス", phonetic: "/ɪnˈtens/", hint: "i" },
            { en: "hostility", ja: "敵意", kana: "ホス**ティ**リティ", phonetic: "/hɑːˈstɪləti/", hint: "h" },
            { en: "grow", ja: "～になる；育つ", kana: "グ**ロ**ウ", phonetic: "/ɡroʊ/", hint: "g" },
            { en: "more and more", ja: "ますます", kana: "**モー**・アンド・**モー**", phonetic: "/mɔːr ænd mɔːr/", hint: "m" }
        ]
    }
];

// --- PERSISTENCE KEYS ---
const KEY_PREFIX = 'duoSelect_';
const KEY = `${KEY_PREFIX}progress_v1`;
const VOICE_MODE = `${KEY_PREFIX}voice_mode_v1`;
const CARD_MODE = `${KEY_PREFIX}card_mode_v1`;
const HINT_MODE = `${KEY_PREFIX}hint_mode_v1`;

// --- [FROM D3.0] PERSISTENCE & SRS ---
function loadProgress() {
    try {
        return JSON.parse(localStorage.getItem(KEY)) || { cards: {} };
    } catch (e) {
        console.error("Failed to load progress:", e);
        return { cards: {} };
    }
}

function saveProgress(p) {
    try {
        localStorage.setItem(KEY, JSON.stringify(p));
    } catch (e) {
        console.error("Failed to save progress:", e);
    }
}

function isDue(card) {
    return !card || !card.next_due || Date.now() >= card.next_due;
}

function tomorrowPlusDays(n = 0) {
    const d = new Date();
    const t = new Date(d.getFullYear(), d.getMonth(), d.getDate() + 1);
    return t.getTime() + n * 86400000;
}

function markWrong(id) {
    const p = loadProgress();
    const c = p.cards[id] || {};
    c.last_result = 'wrong';
    c.interval = 0;
    c.next_due = Date.now() - 1; // Mark as due immediately
    p.cards[id] = c;
    saveProgress(p);
    console.log(`Marked wrong: ${id}`, c);
}

function markCorrect(id) {
    const p = loadProgress();
    const c = p.cards[id] || {};
    c.last_result = 'correct';
    const currentInterval = c.interval || 0;
    const nextInterval = currentInterval === 0 ? 1 : currentInterval === 1 ? 3 : Math.min(currentInterval * 2, 30);
    c.interval = nextInterval;
    c.next_due = tomorrowPlusDays(nextInterval);
    c.done = true;
    p.cards[id] = c;
    saveProgress(p);
    console.log(`Marked correct: ${id}`, c);
}

// --- ID GENERATION ---
function getItemId(sentenceId, type, identifier = '') {
    let safeIdentifier = identifier.toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 20);
    return `s${sentenceId}-${type}${identifier ? `-${safeIdentifier}` : ''}`;
}


// --- STATE ---
let currentSentenceIndex = 0;
let currentStep = 1;
let isSequentialMode = false; 

// --- [REPLACED] Voice/Audio related state
let speechSynthesis = window.speechSynthesis;
// This cache will be populated by the new pickVoices function.
let voiceCache = { male: null, female: null, auto: [], toggle: 0 };

let quizQueue = [];
let stepUnlocked = 1;
let finalCheckCards = [];

// --- DOM ELEMENTS ---
const tocScreen = document.getElementById('toc-screen');
const reviewArea = document.getElementById('review-area');
const mainQuizArea = document.getElementById('main-quiz-area');
const finalCheckArea = document.getElementById('final-check-area');
const resultScreen = document.getElementById('result-screen');
const startSequentialBtn = document.getElementById('start-sequential-btn');
const finalCheckBtn = document.getElementById('final-check-btn');
const nextBtn = document.getElementById('next-btn');
const reviewBtn = document.getElementById('review-btn');
const backToTocBtn = document.getElementById('back-to-toc-btn');
const backToTocFromFinalBtn = document.getElementById('back-to-toc-from-final-btn');
const prevSentenceBtn = document.getElementById('prev-sentence-btn');
const nextSentenceBtn = document.getElementById('next-sentence-btn');
const shuffleFinalCheckBtn = document.getElementById('shuffle-final-check-btn');

const stepViews = {
    1: document.getElementById('step1-quiz'),
    2: document.getElementById('step2-application'),
    3: document.getElementById('step3-flashcards'),
};
const stepIndicatorsContainer = document.getElementById('step-indicators-container');

// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', async () => {
    // Asynchronously load and filter voices first
    if ('speechSynthesis' in window) {
        await pickVoices();
    }
    showMainMenu();
    initAudioControls();
});

// --- EVENT LISTENERS ---
startSequentialBtn.addEventListener('click', () => {
    isSequentialMode = true;
    quizQueue = Array.from(Array(quizData.length).keys());
    startQuizSession(quizQueue);
});

finalCheckBtn.addEventListener('click', () => {
    isSequentialMode = false;
    finalCheckCards = quizData.flatMap(d => 
        d.flashcards.map(fc => ({ ...fc, sentenceId: d.id }))
    );
    finalCheckCards.sort(() => Math.random() - 0.5);
    renderFinalCheck();
});

nextBtn.addEventListener('click', handleNext);
reviewBtn.addEventListener('click', showMainMenu);
backToTocBtn.addEventListener('click', showMainMenu);
backToTocFromFinalBtn.addEventListener('click', showMainMenu);
shuffleFinalCheckBtn.addEventListener('click', () => {
    finalCheckCards.sort(() => Math.random() - 0.5);
    renderFinalCheck();
});

prevSentenceBtn.addEventListener('click', () => {
    if (currentSentenceIndex > 0) {
        navigateToSentence(currentSentenceIndex - 1);
    }
});
nextSentenceBtn.addEventListener('click', () => {
    if (currentSentenceIndex < quizData.length - 1) {
        navigateToSentence(currentSentenceIndex + 1);
    }
});

// Add header button listeners
document.getElementById('header-toc-link').addEventListener('click', (e) => { e.preventDefault(); showMainMenu(); });
document.getElementById('header-review-link').addEventListener('click', (e) => { e.preventDefault(); renderReview(); });
document.getElementById('reset-data-btn').addEventListener('click', () => {
    if (confirm('本当に学習データをすべてリセットしますか？')) {
        localStorage.removeItem(KEY);
        alert('学習データをリセットしました。');
        showMainMenu();
    }
});

stepIndicatorsContainer.addEventListener('click', (e) => {
    if (e.target.matches('.step-indicator')) {
        const targetStep = parseInt(e.target.dataset.step, 10);
        if (targetStep <= stepUnlocked) {
            currentStep = targetStep;
            renderCurrentStep();
        }
    }
});


// --- [NEW] Perfected Voice Logic ---

// Asynchronously gets the list of available voices, waiting if necessary.
function listVoices() {
    return new Promise(resolve => {
        let voices = speechSynthesis.getVoices();
        if (voices.length) {
            return resolve(voices);
        }
        speechSynthesis.onvoiceschanged = () => {
            voices = speechSynthesis.getVoices();
            resolve(voices);
        };
    });
}

// Whitelist of known high-quality English voice names.
const SAFE_EN_VOICE_NAMES = [
    "Alex", "Allison", "Ava", "Daniel", "David", "Fiona", "Fred", "Google US English", "Google UK English Female", "Google UK English Male", "Joelle", "Karen", "Kate", "Lee", "Martha", "Microsoft Aria", "Microsoft David", "Microsoft Guy", "Microsoft Mark", "Microsoft Zira", "Moira", "Nathan", "Oliver", "Rishi", "Samantha", "Susan", "Tessa", "Tom", "Veena", "Victoria"
];

// Blacklist of keywords found in low-quality or novelty voices.
const BLOCKLIST_KEYWORDS = [
    "novelty", "funny", "robot", "morse", "pipe", "organ", "whisper", "laugh", "jiggle", "giggle", "sneeze", "mumble", "zarvox", "good", "news", "bad", "news", "bubbles", "cellos", "deranged", "reflection", "trinoids"
];

// Checks if a voice is on the blocklist.
function isBlockedVoice(v) {
    const name = v.name.toLowerCase();
    const uri = (v.voiceURI || "").toLowerCase();
    return BLOCKLIST_KEYWORDS.some(keyword => name.includes(keyword) || uri.includes(keyword));
}

// Checks if a voice is an approved, high-quality English voice.
function isSafeEnglishVoice(v) {
    if (!v.lang.startsWith("en-") || isBlockedVoice(v)) return false;
    return SAFE_EN_VOICE_NAMES.some(safeName => v.name.includes(safeName));
}

// Gets a filtered list of only safe voices.
async function getSafeEnglishVoices() {
    try {
        const allVoices = await listVoices();
        return allVoices.filter(isSafeEnglishVoice);
    } catch (e) {
        console.error("Error getting safe voices:", e);
        return [];
    }
}

// Detects if the user is on a mobile device.
function isMobile() {
    const ua = navigator.userAgent;
    return /android|iphone|ipad|ipod/i.test(ua);
}

// Populates the voiceCache using a hybrid strategy for mobile and desktop.
async function pickVoices() {
    try {
        const safeVoices = await getSafeEnglishVoices();
        if (safeVoices.length === 0) {
            console.warn("No safe English voices found. Using system defaults as fallback.");
            const allVoices = await listVoices();
            const anyEnVoice = allVoices.filter(v => v.lang.startsWith('en-'));
            voiceCache.auto = anyEnVoice.length ? anyEnVoice : allVoices;
            voiceCache.male = anyEnVoice.find(v => /male/i.test(v.name)) || voiceCache.auto[0];
            voiceCache.female = anyEnVoice.find(v => /female/i.test(v.name)) || voiceCache.auto[0];
            return;
        }

        const isMaleName = (name = "", uri = "") => /(Daniel|Mark|David|Alex(?!a)|George|Tom|Microsoft Mark|Microsoft David|Google UK English Male|male)/i.test(name) || /male/i.test(uri);
        const isFemaleName = (name = "", uri = "") => /(Samantha|Allison|Ava|Victoria|Martha|Aria|Zira|Jenny|Microsoft Aria|Microsoft Zira|Google US English|Google UK English Female|female)/i.test(name) || /female/i.test(uri);

        if (isMobile()) {
            // Mobile: Prioritize stability with specific, reliable voices.
            const mobileMale = safeVoices.find(v => v.name === "Daniel") || safeVoices.find(isMaleName);
            const mobileFemale = safeVoices.find(v => v.name === "Samantha") || safeVoices.find(isFemaleName);
            voiceCache.male = mobileMale || mobileFemale || safeVoices[0];
            voiceCache.female = mobileFemale || mobileMale || safeVoices[0];
            voiceCache.auto = [voiceCache.male, voiceCache.female].filter(Boolean);
        } else {
            // Desktop: Prioritize diversity from the safe list.
            const males = safeVoices.filter(v => isMaleName(v.name, v.voiceURI));
            const females = safeVoices.filter(v => isFemaleName(v.name, v.voiceURI));
            voiceCache.male = males[0] || females[0] || safeVoices[0];
            voiceCache.female = females[0] || males[0] || safeVoices[0];
            voiceCache.auto = [...new Set([...males, ...females, ...safeVoices])];
        }

        if (voiceCache.auto.length === 0) voiceCache.auto.push(safeVoices[0]);
        if (!voiceCache.male) voiceCache.male = voiceCache.auto[0];
        if (!voiceCache.female) voiceCache.female = voiceCache.auto[0];
        
    } catch (e) {
        console.error('Error picking voices', e);
    }
}

// Sanitizes text for Text-to-Speech.
function sanitizeForTTS(s) {
    if (!s) return s;
    let t = s.replace(/\([^)]*\)/g, '').replace(/（[^）]*）/g, '');
    t = t.replace(/<[^>]+>/g, '');
    t = t.replace(/[↔↮→—–…\/｜≠=]/g, ' ');
    t = t.replace(/[\u3040-\u30FF\u3400-\u9FFF\uF900-\uFAFF]/g, '');
    t = t.replace(/\s{2,}/g, ' ').trim();
    return t;
}

function getVoiceMode() { return localStorage.getItem(VOICE_MODE) || 'auto' }

// Main speech function.
function speak(text) {
    if (!('speechSynthesis' in window) || !text) return;
    try { speechSynthesis.cancel(); } catch (e) {}
    
    const prepared = sanitizeForTTS(text);
    if (!prepared) return;

    const rateEl = document.getElementById('rate');
    const rawRate = rateEl ? parseFloat(rateEl.value) : 1.0;
    const mode = getVoiceMode();

    const clamp = (val, min, max) => Math.max(min, Math.min(max, val));

    let voiceToUse = null;
    if (mode === 'male') {
        voiceToUse = voiceCache.male;
    } else if (mode === 'female') {
        voiceToUse = voiceCache.female;
    } else {
        if (voiceCache.auto && voiceCache.auto.length > 0) {
            voiceCache.toggle = (voiceCache.toggle + 1) % voiceCache.auto.length;
            voiceToUse = voiceCache.auto[voiceCache.toggle];
        }
    }
    
    const u = new SpeechSynthesisUtterance(prepared);
    u.lang = 'en-US';
    u.rate = clamp(rawRate, 0.8, 1.2);
    u.pitch = clamp(1.0, 0.85, 1.15);
    u.voice = voiceToUse;
    
    if (u.voice || speechSynthesis.getVoices().length > 0) {
        speechSynthesis.speak(u);
    } else {
        setTimeout(() => {
            if (!u.voice) {
                 if (mode === 'male') voiceToUse = voiceCache.male;
                 else if (mode === 'female') voiceToUse = voiceCache.female;
                 else if (voiceCache.auto && voiceCache.auto.length) voiceToUse = voiceCache.auto[voiceCache.toggle];
                 u.voice = voiceToUse;
            }
            speechSynthesis.speak(u);
        }, 250);
    }
}

function navigateToSentence(index) {
    if (index < 0 || index >= quizData.length) return;

    // Using sentence nav implies individual study mode
    isSequentialMode = false;
    quizQueue = []; // Clear queue

    currentSentenceIndex = index;
    currentStep = 1;
    stepUnlocked = 3; // Unlock all steps immediately for free navigation
    renderCurrentStep();
}

function initAudioControls() {
    // Voice settings
    const voiceSeg = document.getElementById('voiceSeg');
    if (voiceSeg) {
        voiceSeg.addEventListener('click', (e) => {
            const v = e.target?.dataset?.v;
            if (!v) return;
            localStorage.setItem(VOICE_MODE, v);
            syncAppSettings();
        });
    }

    // Card Mode settings
    const cardModeSeg = document.getElementById('cardModeSeg');
    if (cardModeSeg) {
        cardModeSeg.addEventListener('click', (e) => {
            const v = e.target?.dataset?.v;
            if (!v) return;
            localStorage.setItem(CARD_MODE, v);
            syncAppSettings();
        });
    }

    // Hint Mode settings
    const hintModeSeg = document.getElementById('hintModeSeg');
    if (hintModeSeg) {
        hintModeSeg.addEventListener('click', (e) => {
            const v = e.target?.dataset?.v;
            if (!v) return;
            localStorage.setItem(HINT_MODE, v);
            syncAppSettings();
        });
    }

    syncAppSettings();
}

function syncAppSettings() {
    // Sync Voice
    const voiceSeg = document.getElementById('voiceSeg');
    if (voiceSeg) {
        const currentVoiceMode = localStorage.getItem(VOICE_MODE) || 'auto';
        [...voiceSeg.querySelectorAll('button')].forEach(b => b.classList.toggle('on', b.dataset.v === currentVoiceMode));
    }
    
    // Sync Card Mode
    const cardModeSeg = document.getElementById('cardModeSeg');
    const currentCardMode = localStorage.getItem(CARD_MODE) || 'en-ja';
    if (cardModeSeg) {
        [...cardModeSeg.querySelectorAll('button')].forEach(b => b.classList.toggle('on', b.dataset.v === currentCardMode));
    }

    // Sync final check description
    const finalCheckDescription = document.getElementById('final-check-description');
    if (finalCheckDescription) {
        if (currentCardMode === 'ja-en') {
            finalCheckDescription.textContent = '日本語を見て、対応する英単語を思い出してみましょう。カードをタップすると答えが表示されます。';
        } else {
            finalCheckDescription.textContent = '英語を見て、対応する日本語を思い出してみましょう。カードをタップすると答えが表示されます。';
        }
    }

    // Sync Hint Mode and its dependency on Card Mode
    const hintModeSeg = document.getElementById('hintModeSeg');
    if (hintModeSeg) {
        const currentHintMode = localStorage.getItem(HINT_MODE) || 'on';
        const isHintingDisabled = currentCardMode === 'en-ja';
        
        hintModeSeg.style.opacity = isHintingDisabled ? '0.5' : '1';
        [...hintModeSeg.querySelectorAll('button')].forEach(b => {
            b.classList.toggle('on', b.dataset.v === currentHintMode);
            b.disabled = isHintingDisabled;
        });
    }
}

// --- FUNCTIONS ---

function showMainMenu() {
    resultScreen.classList.add('hidden');
    mainQuizArea.classList.add('hidden');
    finalCheckArea.classList.add('hidden');
    reviewArea.classList.add('hidden');
    tocScreen.classList.remove('hidden');
    
    const tocList = document.getElementById('toc-list');
    tocList.innerHTML = '';
    const progress = loadProgress();

    // --- [FROM D3.0] Review Banner Logic ---
    const allDue = Object.keys(progress.cards).filter(id => isDue(progress.cards[id]));
    const urgent = allDue.filter(id => progress.cards[id].last_result === 'wrong');
    const scheduled = allDue.filter(id => progress.cards[id].last_result !== 'wrong');
    
    const reviewBannerContainer = document.getElementById('review-banner-container');
    const headerReviewBadge = document.getElementById('header-review-badge');

    if (allDue.length > 0) {
        reviewBannerContainer.innerHTML = `
            <div class="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 p-4 rounded-lg cursor-pointer hover:bg-yellow-200" id="start-review-btn">
                <p class="font-bold">今日の復習があります！</p>
                <p>期限が来たカードが <span class="font-bold">${allDue.length}</span> 件あります。（要復習: ${urgent.length}件 / 再確認: ${scheduled.length}件）</p>
            </div>
        `;
        document.getElementById('start-review-btn').addEventListener('click', renderReview);
        headerReviewBadge.textContent = allDue.length;
        headerReviewBadge.classList.remove('hidden');
    } else {
        reviewBannerContainer.innerHTML = '';
        headerReviewBadge.classList.add('hidden');
    }


    quizData.forEach((data, index) => {
        // Check for items to review for this sentence
        const quizId = getItemId(data.id, 'quiz');
        const cardIds = data.flashcards.map(fc => getItemId(data.id, 'card', fc.en));
        
        const isQuizDue = progress.cards[quizId] && isDue(progress.cards[quizId]);
        const isVocabDue = cardIds.some(cardId => progress.cards[cardId] && isDue(progress.cards[cardId]));
        const hasDueItems = isQuizDue || isVocabDue;

        const item = document.createElement('button');
        item.className = 'toc-item p-3 border rounded-lg text-center hover:bg-gray-100 transition-colors flex flex-col justify-center items-center h-full';
        if (hasDueItems) item.classList.add('needs-review', 'border-red-400', 'bg-red-50');
        
        let reviewMarksHTML = '<div class="flex items-center space-x-1 mt-1">';
        if (isQuizDue) reviewMarksHTML += '<span class="review-mark" title="クイズ要復習">Q</span>';
        if (isVocabDue) reviewMarksHTML += '<span class="review-mark bg-sky-500" title="単語要復習">V</span>';
        reviewMarksHTML += '</div>';

        item.innerHTML = `
            <div class="toc-item-content">
                <span class="font-semibold">例文 ${data.id}</span>
                ${hasDueItems ? reviewMarksHTML : ''}
            </div>
        `;
        item.onclick = () => {
            isSequentialMode = false;
            startQuizSession([index]);
        };
        tocList.appendChild(item);
    });
}


function startQuizSession(indices) {
    if (indices.length === 0) {
        showMainMenu();
        return;
    }
    
    // This logic correctly handles both sequential (many indices) and individual (one index) modes.
    currentSentenceIndex = indices.shift();
    quizQueue = indices;
    
    currentStep = 1;
    // For individual mode, unlock all steps. For sequential, start from step 1.
    stepUnlocked = 3; 
    tocScreen.classList.add('hidden');
    resultScreen.classList.add('hidden');
    mainQuizArea.classList.remove('hidden');
    nextBtn.classList.add('hidden');
    renderCurrentStep();
}

function handleNext() {
    currentStep++;
    stepUnlocked = Math.max(stepUnlocked, currentStep);

    if (currentStep > 3) { // After flashcards
        if (quizQueue.length > 0) { // More questions in queue
            const session = quizQueue.shift();
            currentSentenceIndex = session;
            currentStep = 1;
            renderCurrentStep();
        } else { // No more questions
            if (isSequentialMode) {
                 showResult();
            } else {
                showMainMenu();
            }
        }
    } else {
        renderCurrentStep();
    }
}


function updateProgress() {
    const currentData = quizData[currentSentenceIndex];
    if (!currentData) return; 

    document.getElementById('question-counter').textContent = `例文 ${currentData.id}`;
    
    if (isSequentialMode) {
        const totalQuestions = quizData.length;
        const completedQuestions = totalQuestions - quizQueue.length - 1;
        const progress = (completedQuestions / totalQuestions) * 100;
        document.getElementById('progress-bar').style.width = `${progress}%`;
        document.getElementById('progress-bar').classList.remove('hidden');

    } else {
        document.getElementById('progress-bar').classList.add('hidden');
    }

    [...stepIndicatorsContainer.children].forEach(el => {
        const step = parseInt(el.dataset.step, 10);
        el.classList.remove('active', 'cursor-pointer', 'hover:bg-gray-200');
        el.disabled = step > stepUnlocked;

        if (step === currentStep) {
            el.classList.add('active');
        } else if (step < stepUnlocked) {
            el.classList.add('cursor-pointer', 'hover:bg-gray-200');
        }
    });
}

function updateSentenceNav() {
    const sentenceNav = document.getElementById('sentence-nav');
    if (isSequentialMode) {
        sentenceNav.classList.add('hidden');
    } else {
        sentenceNav.classList.remove('hidden');
        prevSentenceBtn.disabled = currentSentenceIndex === 0;
        nextSentenceBtn.disabled = currentSentenceIndex === quizData.length - 1;
    }
}

function renderCurrentStep() {
    updateProgress();
    Object.values(stepViews).forEach(view => view.classList.add('hidden'));
    stepViews[currentStep].classList.remove('hidden');
    nextBtn.classList.add('hidden');
    updateSentenceNav();

    const data = quizData[currentSentenceIndex];
    if (!data) return; 

    switch (currentStep) {
        case 1: renderStep1(data); break;
        case 2: renderStep2(data); break;
        case 3: renderStep3(data); break;
    }
}

// --- RENDER FUNCTIONS FOR EACH STEP ---

function renderStep1(data) {
    const { quiz, originalSentence } = data;
    const questionText = originalSentence.replace(new RegExp(quiz.target.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"), 'i'), '______');
    const shuffledChoices = [...quiz.choices].sort(() => Math.random() - 0.5);
    
    let optionsHTML = shuffledChoices.map(choice => 
        `<button class="btn-option w-full p-4 bg-white border border-gray-300 rounded-lg text-left text-gray-700 font-medium transition-all duration-200">${choice}</button>`
    ).join('');

    stepViews[1].innerHTML = `
        <p class="text-sm text-gray-500 text-center mb-4">あてはまる選択肢を選びましょう。</p>
        <div class="mb-6 relative">
            <p class="text-xl md:text-2xl text-gray-800 text-center p-4 bg-gray-50 rounded-lg">${questionText}</p>
            <button class="speaker-btn text-xl" onclick="speak('${originalSentence.replace(/'/g, "\\'")}')"><i class="fas fa-volume-up"></i></button>
        </div>
        <div id="step1-options" class="grid grid-cols-1 md:grid-cols-2 gap-4">${optionsHTML}</div>
        <div id="step1-feedback" class="p-4 rounded-lg text-center font-medium hidden my-4"></div>
    `;

    document.getElementById('step1-options').addEventListener('click', e => {
        if (e.target.tagName === 'BUTTON') {
            handleQuizAnswer(e.target, quiz, data.translation);
        }
    });
}

function handleQuizAnswer(selectedButton, quizInfo, translation) {
    const isCorrect = selectedButton.innerText.toLowerCase() === quizInfo.target.toLowerCase();
    const itemId = getItemId(quizData[currentSentenceIndex].id, 'quiz');
    
    if (isCorrect) {
        markCorrect(itemId);
    } else {
        markWrong(itemId);
    }
    
    const feedbackEl = document.getElementById('step1-feedback');
    
    if (isCorrect) {
        feedbackEl.innerHTML = `正解！ <span class="font-bold">${quizInfo.target}</span> は「${quizInfo.meaning}」という意味です。`;
        feedbackEl.className = 'p-4 rounded-lg text-center font-medium my-4 bg-green-100 border border-green-300 text-green-800';
    } else {
        feedbackEl.innerHTML = `不正解。正解は <span class="font-bold">${quizInfo.target}</span> です。<br>「${quizInfo.meaning}」という意味になります。`;
        feedbackEl.className = 'p-4 rounded-lg text-center font-medium my-4 bg-red-100 border border-red-300 text-red-800';
    }
    feedbackEl.classList.remove('hidden');
    
    const translationEl = document.createElement('p');
    translationEl.className = 'text-center text-gray-600 mt-2';
    translationEl.textContent = `文全体の訳：${translation}`;
    feedbackEl.appendChild(translationEl);

    Array.from(document.getElementById('step1-options').children).forEach(button => {
        button.disabled = true;
        if (button.innerText.toLowerCase() === quizInfo.target.toLowerCase()) button.classList.add('bg-green-200', 'border-green-500');
        else if (button === selectedButton) button.classList.add('bg-red-200', 'border-red-500');
    });

    nextBtn.textContent = '応用例文へ →';
    nextBtn.classList.remove('hidden');
}

function renderStep2(data) {
    const { application } = data;
    stepViews[2].innerHTML = `
        <p class="text-sm text-gray-500 text-center mb-4">応用例文で使い方を確認しましょう。</p>
        <div class="bg-sky-50 border-l-4 border-sky-500 p-4 rounded-lg mb-4">
            <p class="font-semibold text-sky-800 mb-2">💡 こんな場面で使える！</p>
            <p class="text-gray-700">${application.situation}</p>
        </div>
        <div class="mb-4 relative p-4 bg-gray-50 rounded-lg">
            <p class="text-lg md:text-xl text-gray-800">${application.sentence}</p>
            <button class="speaker-btn text-xl" onclick="speak(this.previousElementSibling.innerText.replace(/'/g, &quot;\\'&quot;))"><i class="fas fa-volume-up"></i></button>
        </div>
        <div class="text-center mb-6">
            <button id="show-translation-btn" class="text-blue-600 hover:underline">日本語訳を見る</button>
        </div>
        <p id="translation-text" class="text-center text-gray-600 hidden mb-6">${application.translation}</p>
    `;

    stepViews[2].querySelector('#show-translation-btn').addEventListener('click', e => {
        document.getElementById('translation-text').classList.toggle('hidden');
        e.target.textContent = document.getElementById('translation-text').classList.contains('hidden') ? '日本語訳を見る' : '日本語訳を隠す';
    });

    // Automatically show the next button
    nextBtn.textContent = '単語カードへ →';
    nextBtn.classList.remove('hidden');
    stepUnlocked = Math.max(stepUnlocked, 3); // Unlock next step
    updateProgress(); // To enable the step 3 button
}

function renderFlashcards(container, cards, isFinalCheck = false) {
    container.innerHTML = '';
    const progress = loadProgress();

    const savedCardMode = localStorage.getItem(CARD_MODE) || 'en-ja';
    const savedHintMode = localStorage.getItem(HINT_MODE) || 'on';
    const isHintVisible = (savedCardMode === 'ja-en' && savedHintMode === 'on');

    cards.forEach(card => {
        const sentenceId = isFinalCheck ? card.sentenceId : quizData[currentSentenceIndex].id;
        const cardId = getItemId(sentenceId, 'card', card.en);
        const cardProgress = progress.cards[cardId];
        
        const cardEl = document.createElement('div');
        // We wrap the card in an outer div to hold the buttons
        cardEl.className = 'flex flex-col gap-2';
        
        const flashcardDiv = document.createElement('div');
        flashcardDiv.className = 'flashcard h-48 relative'; // Add relative positioning for the badge

        let statusBadgeHTML = '';
        if (cardProgress && isDue(cardProgress) && cardProgress.last_result === 'wrong') {
            statusBadgeHTML = '<span class="absolute top-2 left-2 text-xs bg-red-100 text-red-700 px-2 py-0.5 rounded-full z-10">要復習</span>';
        } else if (cardProgress && isDue(cardProgress)) {
            statusBadgeHTML = '<span class="absolute top-2 left-2 text-xs bg-blue-100 text-blue-700 px-2 py-0.5 rounded-full z-10">再確認</span>';
        } else if (cardProgress && cardProgress.done) {
            statusBadgeHTML = '<span class="absolute top-2 left-2 text-xs bg-green-100 text-green-700 px-2 py-0.5 rounded-full z-10">できた</span>';
        }

        const frontContent = (savedCardMode === 'en-ja') 
            ? `<h3 class="text-2xl font-bold">${card.en}</h3>`
            : `<h3 class="text-xl font-bold">${card.ja}</h3>${isHintVisible ? `<p class="text-gray-500 mt-2">ヒント: ${card.hint}</p>` : ''}`;
        
        const backContent = (savedCardMode === 'en-ja')
            ? `<h3 class="text-xl font-bold">${card.ja}</h3>`
            : `<h3 class="text-2xl font-bold">${card.en}</h3>`;

        flashcardDiv.innerHTML = `
            ${statusBadgeHTML}
            <div class="flashcard-inner">
                <div class="flashcard-front">${frontContent}<button class="speaker-btn"><i class="fas fa-volume-up"></i></button></div>
                <div class="flashcard-back">
                    ${backContent}
                    <div class="text-center mt-2">
                        <p class="text-gray-500">${card.kana.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>')}</p>
                        <p class="text-gray-400 text-sm">${card.phonetic}</p>
                    </div>
                    <button class="speaker-btn"><i class="fas fa-volume-up"></i></button>
                </div>
            </div>
        `;
        flashcardDiv.addEventListener('click', () => flashcardDiv.classList.toggle('flipped'));
        // Add speaker functionality to both buttons
        flashcardDiv.querySelectorAll('.speaker-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent card from flipping when clicking button
                speak(card.en);
            });
        });
        
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'grid grid-cols-2 gap-2';
        
        const correctBtn = document.createElement('button');
        correctBtn.textContent = 'できた';
        correctBtn.className = 'w-full py-2 px-4 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors';
        correctBtn.onclick = (e) => {
            e.stopPropagation();
            markCorrect(cardId);
            if (isFinalCheck) {
                renderFinalCheck(); // Re-render the whole final check screen
            } else {
                renderCurrentStep(); // Re-render to update badge
            }
        };

        const wrongBtn = document.createElement('button');
        wrongBtn.textContent = 'あとで復習';
        wrongBtn.className = 'w-full py-2 px-4 bg-white border border-gray-300 text-gray-700 rounded-lg hover:bg-gray-100 transition-colors';
        wrongBtn.onclick = (e) => {
            e.stopPropagation();
            markWrong(cardId);
            if (isFinalCheck) {
                renderFinalCheck(); // Re-render the whole final check screen
            } else {
                renderCurrentStep(); // Re-render to update badge
            }
        };

        buttonContainer.append(wrongBtn, correctBtn);
        cardEl.append(flashcardDiv, buttonContainer);
        container.appendChild(cardEl);
    });
}

function renderStep3(data) {
    const { flashcards } = data;
    
    stepViews[3].innerHTML = `
        <p class="text-sm text-gray-500 text-center mb-4">カードをタップして関連単語も覚えましょう。</p>
        <div id="flashcard-container-step3" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
    `;

    const container = document.getElementById('flashcard-container-step3');
    renderFlashcards(container, flashcards);

    const nextText = quizQueue.length === 0 ? 
        (isSequentialMode ? '結果を見る' : '目次に戻る') : 
        '次の問題へ →';
    nextBtn.textContent = nextText;
    nextBtn.classList.remove('hidden');
}

function renderFinalCheck() {
    tocScreen.classList.add('hidden');
    mainQuizArea.classList.add('hidden');
    resultScreen.classList.add('hidden');
    finalCheckArea.classList.remove('hidden');
    syncAppSettings(); // Sync description text based on mode

    const container = document.getElementById('final-check-flashcards');
    renderFlashcards(container, finalCheckCards, true);
}

function showResult() {
    mainQuizArea.classList.add('hidden');
    resultScreen.classList.remove('hidden');
    
    const summaryEl = document.getElementById('self-assessment-summary');
    summaryEl.innerHTML = `
        <p class="text-xl">お疲れ様でした！</p>
        <p class="text-gray-600 mt-2">間違えた問題や「あとで復習」を選んだ問題は、目次画面から再度挑戦できます。</p>
    `;
}

// --- [FROM D3.0] Full Review Session Logic ---
function renderReview() {
    tocScreen.classList.add('hidden');
    mainQuizArea.classList.add('hidden');
    finalCheckArea.classList.add('hidden');
    reviewArea.classList.remove('hidden');

    const progress = loadProgress();
    const allDue = Object.keys(progress.cards).filter(id => isDue(progress.cards[id]));
    const urgent = allDue.filter(id => progress.cards[id].last_result === 'wrong').sort((a,b) => (progress.cards[a].next_due || 0) - (progress.cards[b].next_due || 0));
    const scheduled = allDue.filter(id => progress.cards[id].last_result !== 'wrong').sort((a,b) => (progress.cards[a].next_due || 0) - (progress.cards[b].next_due || 0));
    
    const reviewQueue = [...urgent, ...scheduled];
    let currentIndex = 0;

    function findDataById(itemId) {
        const parts = itemId.split('-');
        const sentenceId = parseInt(parts[0].substring(1), 10);
        const type = parts[1];
        const sentenceData = quizData.find(d => d.id === sentenceId);
        if (!sentenceData) return null;

        if (type === 'quiz') {
            return { type, sentence: sentenceData };
        }
        if (type === 'card') {
            const identifier = parts.slice(2).join('-');
            const cardData = sentenceData.flashcards.find(fc => fc.en.toLowerCase().replace(/[^a-z0-9]/g, '_').substring(0, 20) === identifier);
            return { type, sentence: sentenceData, card: cardData };
        }
        return null; // Should not happen
    }

    function renderNextItem() {
        if (currentIndex >= reviewQueue.length) {
            reviewArea.innerHTML = `
                <div class="text-center">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">復習完了！</h2>
                    <p class="text-gray-600 mb-6">お疲れ様でした。すべての復習項目が終わりました。</p>
                    <button id="review-back-to-toc" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full">目次に戻る</button>
                </div>
            `;
            document.getElementById('review-back-to-toc').addEventListener('click', showMainMenu);
            return;
        }

        const itemId = reviewQueue[currentIndex];
        const itemData = findDataById(itemId);

        if (!itemData || (itemData.type === 'card' && !itemData.card)) {
            console.warn(`Could not find data for review item: ${itemId}. Skipping.`);
            currentIndex++;
            renderNextItem();
            return;
        }

        reviewArea.innerHTML = `
            <div class="w-full bg-gray-200 rounded-full h-2.5 mb-6">
                <div class="bg-blue-500 h-2.5 rounded-full" style="width: ${((currentIndex) / reviewQueue.length) * 100}%; transition: width 0.3s;"></div>
            </div>
            <div id="review-item-content"></div>
        `;
        const contentEl = document.getElementById('review-item-content');

        const advance = () => {
            currentIndex++;
            // Give a short delay to see the result before the next item renders
            setTimeout(renderNextItem, 600);
        };

        if (itemData.type === 'quiz') {
            const { sentence } = itemData;
            const { quiz } = sentence;
            const questionText = sentence.originalSentence.replace(new RegExp(quiz.target.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1"), 'i'), '______');
            const shuffledChoices = [...quiz.choices].sort(() => Math.random() - 0.5);
            let optionsHTML = shuffledChoices.map(choice => 
                `<button class="btn-option w-full p-3 bg-white border border-gray-300 rounded-lg text-left text-gray-700 font-medium">${choice}</button>`
            ).join('');

            contentEl.innerHTML = `
                <p class="text-sm text-gray-500 mb-2">例文 ${sentence.id} - 空所補充</p>
                <div class="mb-4 relative">
                    <p class="text-lg text-gray-800 text-center p-4 bg-gray-50 rounded-lg">${questionText}</p>
                    <button id="review-quiz-tts-btn" class="speaker-btn"><i class="fas fa-volume-up"></i></button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-3" id="review-options">
                    ${optionsHTML}
                </div>
            `;
            contentEl.querySelector('#review-quiz-tts-btn').addEventListener('click', () => speak(sentence.originalSentence));

            contentEl.querySelector('#review-options').addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    const isCorrect = e.target.innerText.toLowerCase() === quiz.target.toLowerCase();
                    if (isCorrect) markCorrect(itemId); else markWrong(itemId);
                    
                    Array.from(contentEl.querySelector('#review-options').children).forEach(button => {
                        button.disabled = true;
                        if (button.innerText.toLowerCase() === quiz.target.toLowerCase()) button.classList.add('!bg-green-200', '!border-green-500');
                        else if (button === e.target) button.classList.add('!bg-red-200', '!border-red-500');
                    });
                    advance();
                }
            });
        } else if (itemData.type === 'card') {
            const { card } = itemData;
            const cardContainer = document.createElement('div');
            // Temporarily set currentSentenceIndex for renderFlashcards to work
            const originalIndex = currentSentenceIndex;
            currentSentenceIndex = quizData.findIndex(d => d.id === itemData.sentence.id);
            renderFlashcards(cardContainer, [card]); 
            currentSentenceIndex = originalIndex; // Restore it

            contentEl.innerHTML = `<p class="text-sm text-gray-500 mb-2">例文 ${itemData.sentence.id} - 単語カード</p>`;
            contentEl.appendChild(cardContainer);

            // Override card buttons for review context
            const correctBtn = cardContainer.querySelector('.bg-green-500');
            const wrongBtn = cardContainer.querySelector('.border-gray-300');
            if (correctBtn) correctBtn.onclick = (e) => { e.stopPropagation(); markCorrect(itemId); correctBtn.style.opacity = '1'; wrongBtn.style.opacity = '0.5'; advance(); };
            if (wrongBtn) wrongBtn.onclick = (e) => { e.stopPropagation(); markWrong(itemId); wrongBtn.style.opacity = '1'; correctBtn.style.opacity = '0.5'; advance(); };
        }
    }

    if (reviewQueue.length > 0) {
        renderNextItem();
    } else {
        reviewArea.innerHTML = `
             <div class="text-center">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">今日の復習はありません</h2>
                <p class="text-gray-600 mb-6">素晴らしいです！復習が必要な項目は今のところありません。</p>
                <button id="review-back-to-toc" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full">目次に戻る</button>
            </div>
        `;
        document.getElementById('review-back-to-toc').addEventListener('click', showMainMenu);
    }
}

// --- [DEBUG] This is a temporary function to display voices directly on the page ---
async function displayVoiceListForDebug() {
    try {
        // This function should already exist in the main script block
        const listVoices = () => new Promise(resolve => {
            let voices = speechSynthesis.getVoices();
            if (voices.length) return resolve(voices);
            speechSynthesis.onvoiceschanged = () => resolve(speechSynthesis.getVoices());
        });

        const voices = await listVoices();
        const tocScreen = document.getElementById('toc-screen');
        if (!tocScreen) return;

        const debugDiv = document.createElement('div');
        debugDiv.style.cssText = 'padding: 1rem; border: 2px solid red; margin: 1rem 0; background-color: #fff0f0; font-family: monospace; font-size: 12px; line-height: 1.5; text-align: left;';

        let html = '<h2 style="font-weight: bold; font-size: 16px; margin-bottom: 10px;">利用可能な音声リスト（この内容をコピーしてください）</h2><ul>';
        if (voices.length > 0) {
            voices.forEach(v => {
                html += `<li><strong>name:</strong> ${v.name}, <strong>lang:</strong> ${v.lang}, <strong>default:</strong> ${v.default}</li>`;
            });
        } else {
            html += '<li>利用可能な音声が見つかりませんでした。ページを再読み込みしてみてください。</li>';
        }
        html += '</ul>';

        debugDiv.innerHTML = html;
        tocScreen.prepend(debugDiv);
    } catch (e) {
        // Fallback for error
        const tocScreen = document.getElementById('toc-screen');
        if(tocScreen) tocScreen.insertAdjacentHTML('afterbegin', '<div style="color: red; border: 1px solid red; padding: 10px;">音声リストの取得中にエラーが発生しました。</div>');
    }
}
</script>
</body>
</html>